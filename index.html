<!DOCTYPE html>
<html>
<head>
    <title>Bungee Analyzer: Iterative Predictor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.20.0.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 40px; background: #f4f7f6; color: #333; }
        .container { max-width: 1000px; margin: auto; background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        textarea { width: 100%; height: 180px; font-family: monospace; margin-bottom: 20px; border: 1px solid #ccc; padding: 10px; }
        button { background: #2c3e50; color: white; border: none; padding: 12px 20px; cursor: pointer; border-radius: 4px; font-size: 16px; transition: 0.3s; }
        button:hover { background: #34495e; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .card { padding: 15px; border: 1px solid #ddd; border-radius: 6px; background: #fff; }
        .cleaned { border-left: 5px solid #27ae60; background: #f0fff4; }
        .predictor-box { background: #e8eff5; padding: 20px; border-radius: 8px; margin-top: 30px; border: 1px solid #b8c9d6; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .outlier-row { background-color: #ffe6e6; text-decoration: line-through; color: #c0392b; }
        .highlight { color: #27ae60; font-weight: bold; font-size: 1.2em; }
        input { padding: 8px; width: 80px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }
    </style>
</head>
<body>

<div class="container">
    <h1>Bungee Analyzer</h1>
    <p>Paste data (headers: height mass chord distance):</p>
    <textarea id="dataInput">height mass chord distance
69.75 200.35 0.25 3.5
69.75 200.35 0.00 31.0
69.75 200.35 0.26 2.5
69.75 200.35 0.27 0.5
69.75 251.54 0.25 0.8
69.75 251.54 0.00 29.0
69.75 251.54 0.10 17.0
80.00 344.32 0.55 16.0
80.00 344.32 0.60 9.0
80.00 344.32 0.65 3.0
80.00 344.32 0.67 1.0
80.00 485.84 0.50 16.0
80.00 485.84 0.60 4.0
80.00 485.84 0.63 1.0</textarea>
    
    <button onclick="analyze()">Perform Dual Analysis</button>

    <div id="resultsView" style="display:none;">
        <div class="grid">
            <div class="card">
                <h3>1. Original (All Data)</h3>
                <p>R²: <b id="r2_orig"></b></p>
                <div id="eq_orig" style="font-size:0.8em; font-family:monospace;"></div>
            </div>

            <div class="card cleaned">
                <h3>2. Cleaned (No Outliers)</h3>
                <p>R²: <b id="r2_clean"></b></p>
                <div id="eq_clean" style="font-size:0.8em; font-family:monospace; font-weight:bold;"></div>
            </div>
        </div>

        <div class="predictor-box">
            <h3>Target Predictor</h3>
            <p>Enter the conditions for your next drop:</p>
            Drop Height (H): <input type="number" id="predH" step="0.1" value="80"> 
            Mass (M): <input type="number" id="predM" step="0.1" value="400">
            <button onclick="predictChord()" style="background:#2980b9">Calculate Optimal Chord</button>
            
            <div id="predictionResult" style="margin-top:15px; display:none;">
                Recommended Chord Length: <span class="highlight" id="optChord">--</span> meters
                <p><small><i>This length aims for a clearance of 0.5 cm.</i></small></p>
                <hr>
                <p><b>Test Result:</b> After dropping, enter the actual distance achieved:</p>
                Actual Distance (cm): <input type="number" id="actualDist" step="0.1" placeholder="e.g. 0.8">
                <button onclick="appendToData()" style="background:#27ae60">Confirm & Add to Dataset</button>
            </div>
        </div>

        <div id="mainPlot"></div>
        <h3>Data Review</h3>
        <div id="tableOutput"></div>
    </div>
</div>

<script>
let globalCoeffs = []; // To store cleaned coefficients for prediction

function solveRegression(h, m, c, y) {
    // STABLE MATRIX: [1, h, m, c, h^2] 
    // We remove m^2 and c^2 to prevent the "Trillion" error
    const X = h.map((_, i) => [1, h[i], m[i], c[i], h[i]**2]);
    const Xt = math.transpose(X);
    const XtX = math.multiply(Xt, X);
    const Xty = math.multiply(Xt, y);
    
    // Using pinv (pseudo-inverse) is safer against giant numbers
    const XtX_inv = math.pinv(XtX);
    const coeffs = math.multiply(XtX_inv, Xty).map(val => val);
    
    const yPred = X.map(row => math.multiply(row, coeffs));
    const residuals = y.map((val, i) => val - yPred[i]);
    const r2 = 1 - (math.sum(residuals.map(r => r**2)) / math.sum(y.map(val => (val - math.mean(y))**2)));
    
    let eqTerms = ["", "h", "m", "c", "h²"];
    let formula = `${coeffs[0].toFixed(4)}`;
    for(let i=1; i<coeffs.length; i++) {
        formula += ` ${coeffs[i] >= 0 ? '+' : '-'} ${Math.abs(coeffs[i]).toFixed(4)}${eqTerms[i]}`;
    }
    
    return { coeffs, yPred, residuals, r2, formula };
}

function analyze() {
    const input = document.getElementById('dataInput').value.trim();
    const rows = input.split('\n').map(r => r.trim().split(/\s+/));
    rows.shift(); 
    
    let h = [], m = [], c = [], y = [];
    rows.forEach(row => {
        h.push(parseFloat(row[0]));
        m.push(parseFloat(row[1]));
        c.push(parseFloat(row[2]));
        y.push(parseFloat(row[3]));
    });

    const orig = solveRegression(h, m, c, y);
    const stdDev = math.std(orig.residuals);
    const isOutlier = orig.residuals.map(r => Math.abs(r) > (1.5 * stdDev));

    let h_c = [], m_c = [], c_c = [], y_c = [];
    isOutlier.forEach((out, i) => {
        if(!out) {
            h_c.push(h[i]); m_c.push(m[i]); c_c.push(c[i]); y_c.push(y[i]);
        }
    });

    const cleaned = solveRegression(h_c, m_c, c_c, y_c);
    globalCoeffs = cleaned.coeffs; // Store for predictor

    document.getElementById('resultsView').style.display = 'block';
    document.getElementById('r2_orig').innerText = orig.r2.toFixed(4);
    document.getElementById('eq_orig').innerText = "d = " + orig.formula;
    document.getElementById('r2_clean').innerText = cleaned.r2.toFixed(4);
    document.getElementById('eq_clean').innerText = "d = " + cleaned.formula;

    let tableHtml = '<table><tr><th>H</th><th>M</th><th>C</th><th>Actual</th><th>Status</th></tr>';
    rows.forEach((row, i) => {
        tableHtml += `<tr class="${isOutlier[i] ? 'outlier-row' : ''}">
            <td>${h[i]}</td><td>${m[i]}</td><td>${c[i]}</td><td>${y[i]}</td>
            <td>${isOutlier[i] ? "outlier" : "fitted"}</td></tr>`;
    });
    document.getElementById('tableOutput').innerHTML = tableHtml + '</table>';

    Plotly.newPlot('mainPlot', [
        { x: c, y: y, mode: 'markers', name: 'Raw Data', marker: {color: 'grey', opacity: 0.5} },
        { x: c_c, y: y_c, mode: 'markers', name: 'Clean Data', marker: {color: 'blue', size: 10} }
    ], { title: 'Chord Length (M) vs Distance (cm)', xaxis:{title:'Chord (m)'}, yaxis:{title:'Dist (cm)'} });
}

ffunction predictChord() {
    if(globalCoeffs.length === 0) return alert("Run analysis first.");
    
    const h = parseFloat(document.getElementById('predH').value);
    const m = parseFloat(document.getElementById('predM').value);
    const targetD = parseFloat(document.getElementById('targetD').value);

    const b = globalCoeffs;
    // d = b0 + b1h + b2m + b3c + b4h^2
    // Solve for c: c = (targetD - b0 - b1h - b2m - b4h^2) / b3
    const c = (targetD - b[0] - b[1]*h - b[2]*m - b[4]*h**2) / b[3];

    if (c < 0 || c > h) {
        alert("The model suggests this drop is physically impossible with current chord types.");
    } else {
        document.getElementById('optChord').innerText = c.toFixed(4);
        document.getElementById('predictionResult').style.display = 'block';
    }
}

function appendToData() {
    const h = document.getElementById('predH').value;
    const m = document.getElementById('predM').value;
    const c = document.getElementById('optChord').innerText;
    const dist = document.getElementById('actualDist').value;

    if(!dist) return alert("Enter the actual distance first!");

    const newData = `\n${h} ${m} ${c} ${dist}`;
    document.getElementById('dataInput').value += newData;
    
    alert("New data point added! Re-running analysis...");
    analyze();
    
    // Reset predictor
    document.getElementById('predictionResult').style.display = 'none';
    document.getElementById('actualDist').value = "";
}
</script>
</body>
</html>
